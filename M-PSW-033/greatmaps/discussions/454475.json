[
  {
    "Id": "1084667",
    "ThreadId": "454475",
    "Html": "Based on <a href=\"http://www.movable-type.co.uk/scripts/latlong.html\" rel=\"nofollow\">http://www.movable-type.co.uk/scripts/latlong.html</a> I programmed methods to calculate intersection points for 2 given GMapRoutes. You get a list with ALL intersection points, the routes can have as many pointa as you want. Of course for long routes the calculation takes longer. The code is below if anyone is interested, perhaps <strong>radioman</strong> you want to include it in the next build?\r<br />\n<br />\nI noticed, that if the length of the linesegments that make up the polylines are large, the result is off, check out this screenshot (the green point is the calculated intersection point):\r<br />\n<br />\n<img src=\"https://dl.dropboxusercontent.com/u/7026787/Screenshots/Intersection.png\" alt=\"Image\" />\r<br />\n<br />\nI think, the problem is, that the GMapRoute is just a straight line on the map, and does not follow the curvature of the earth, is this correct, radioman?<br />\n<pre><code>/// &lt;summary&gt;\n        /// Gets a List with all intersection points for two given Routes\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;route1&quot;&gt;&lt;/param&gt;\n        /// &lt;param name=&quot;route2&quot;&gt;&lt;/param&gt;\n        /// &lt;returns&gt;List of intersection points&lt;/returns&gt;\n        public static List&lt;PointLatLng&gt; GetPolyLineIntersections(GMapRoute route1, GMapRoute route2)\n        {\n            return GetPolyLineIntersections(route1.Points, route2.Points);\n        }\n\n\n        /// &lt;summary&gt;\n        /// Gets a list with all intersection points for two given Polylines\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;points1&quot;&gt;List of PointLatLng that define the first polyline.&lt;/param&gt;\n        /// &lt;param name=&quot;points2&quot;&gt;List of PointLatLng that define the second polyline.&lt;/param&gt;\n        /// &lt;returns&gt;List of intersection points&lt;/returns&gt;\n        public static List&lt;PointLatLng&gt; GetPolyLineIntersections(List&lt;PointLatLng&gt; points1, List&lt;PointLatLng&gt; points2)\n        {\n            List&lt;PointLatLng&gt; retList = new List&lt;PointLatLng&gt;();\n\n            //Check EVERY LineSegment with EVERY other segment!\n            for (int i = 0; i &lt; points1.Count - 1; i++)\n            {\n                PointLatLng p1Start = points1[i];\n                PointLatLng p1End = points1[i + 1];\n\n                for (int j = 0; j &lt; points2.Count - 1; j++)\n                {\n                    PointLatLng p2Start = points2[j];\n                    PointLatLng p2End = points2[j + 1];\n\n                    PointLatLng intersection = GetLineSegmentIntersection(p1Start, p1End, p2Start, p2End);\n                    if (false == intersection.IsEmpty)\n                    {\n                        retList.Add(intersection);\n                    }\n                }\n            }\n            return retList;\n        }\n\n        /// &lt;summary&gt;\n        /// Get the intersection between 2 line Segments with given Start and Endpoints\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;start1&quot;&gt;The start point of linesegment 1&lt;/param&gt;\n        /// &lt;param name=&quot;end1&quot;&gt;The end point of linesegment 1&lt;/param&gt;\n        /// &lt;param name=&quot;start2&quot;&gt;The start point of linesegment 2&lt;/param&gt;\n        /// &lt;param name=&quot;end2&quot;&gt;The end point of linesegment 2&lt;/param&gt;\n        /// &lt;returns&gt;Intersectionpoint or Empty Point if there is no intersection&lt;/returns&gt;\n        public static PointLatLng GetLineSegmentIntersection(PointLatLng start1, PointLatLng end1, PointLatLng start2, PointLatLng end2)\n        {\n            double bearing1 = GMapProviders.EmptyProvider.Projection.GetBearing(start1, end1);\n            double bearing2 = GMapProviders.EmptyProvider.Projection.GetBearing(start2, end2);\n\n            return GetLineSegmentIntersection(start1, bearing1, start2, bearing2, end1, end2);\n        }\n\n        \n        /// &lt;summary&gt;\n        /// Returns the point of intersection of two paths defined by point and bearing\n        /// &lt;/summary&gt;\n        /// &lt;see cref=&quot;http://williams.best.vwh.net/avform.htm#Intersection&quot;/&gt;\n        /// &lt;param name=&quot;start1&quot;&gt;First point&lt;/param&gt;\n        /// &lt;param name=&quot;brng1&quot;&gt;Initial bearing from first point&lt;/param&gt;\n        /// &lt;param name=&quot;start2&quot;&gt;Second point&lt;/param&gt;\n        /// &lt;param name=&quot;brng2&quot;&gt;Initial bearing from second point&lt;/param&gt;\n        /// &lt;returns&gt;Destination point (PointLatLng.Empty if no unique intersection defined)&lt;/returns&gt;\n        public static PointLatLng GetLineSegmentIntersection(PointLatLng start1, double brng1, PointLatLng start2, double brng2, PointLatLng end1, PointLatLng end2)\n        {\n            double lat1 = ToRadians(start1.Lat);\n            double lon1 = ToRadians(start1.Lng);\n            double lat2 = ToRadians(start2.Lat);\n            double lon2 = ToRadians(start2.Lng);\n            double brng13 = ToRadians(brng1);\n            double brng23 = ToRadians(brng2);\n\n            double dLat = lat2 - lat1;\n            double dLon = lon2 - lon1;\n  \n            double dist12 = 2d * Math.Asin(Math.Sqrt( Math.Sin(dLat / 2d) * Math.Sin(dLat / 2d) + Math.Cos(lat1) * Math.Cos(lat2) * Math.Sin(dLon / 2d) * Math.Sin(dLon / 2d)));\n            if (dist12 == 0d)\n            {\n                return PointLatLng.Empty;\n            }\n  \n            // initial/final bearings between points\n            double brngA = Math.Acos((Math.Sin(lat2) - Math.Sin(lat1) * Math.Cos(dist12)) / (Math.Sin(dist12) * Math.Cos(lat1)));\n            if (Double.IsNaN(brngA))\n            {\n                // protect against rounding\n                brngA = 0d;  \n            }\n            double brngB = Math.Acos((Math.Sin(lat1) - Math.Sin(lat2) * Math.Cos(dist12)) / (Math.Sin(dist12) * Math.Cos(lat2)));\n              \n            double brng12, brng21;\n            if (Math.Sin(lon2 - lon1) &gt; 0d)\n            {\n            brng12 = brngA;\n            brng21 = 2d * Math.PI - brngB;\n            }\n            else\n            {\n            brng12 = 2d * Math.PI - brngA;\n            brng21 = brngB;\n            }\n  \n            double alpha1 = (brng13 - brng12 + Math.PI) % (2d * Math.PI) - Math.PI;  // angle 2-1-3\n            double alpha2 = (brng21 - brng23 + Math.PI) % (2d * Math.PI) - Math.PI;  // angle 1-2-3\n  \n            if(Math.Sin(alpha1) == 0d &amp;&amp; Math.Sin(alpha2) == 0d)\n            {\n                //Infinite intersections\n                return PointLatLng.Empty;  \n            }\n            if(Math.Sin(alpha1) * Math.Sin(alpha2) &lt; 0d)\n            {\n                //Ambiguous intersection\n                return PointLatLng.Empty;       \n            }\n   \n            double alpha3 = Math.Acos(-Math.Cos(alpha1) * Math.Cos(alpha2) + Math.Sin(alpha1) * Math.Sin(alpha2) * Math.Cos(dist12));\n            double dist13 = Math.Atan2(Math.Sin(dist12) * Math.Sin(alpha1) * Math.Sin(alpha2), Math.Cos(alpha2) + Math.Cos(alpha1) * Math.Cos(alpha3));\n            double lat3 = Math.Asin(Math.Sin(lat1) * Math.Cos(dist13) + Math.Cos(lat1) * Math.Sin(dist13) * Math.Cos(brng13));\n            double dLon13 = Math.Atan2(Math.Sin(brng13) * Math.Sin(dist13) * Math.Cos(lat1), Math.Cos(dist13) - Math.Sin(lat1) * Math.Sin(lat3));\n            double lon3 = lon1 + dLon13;\n\n            //Normalise to -180...+180Â°\n            lon3 = (lon3 + 3d * Math.PI) % (2d * Math.PI) - Math.PI;  \n\n            PointLatLng intersect = new PointLatLng(ToDegrees(lat3), ToDegrees(lon3));\n\n            //Check if intersection point is inside the bounding box of BOTH rectangles defined by start and end points!\n            if (IsPointInBoundingBox(start1, end1, intersect) &amp;&amp; IsPointInBoundingBox(start2, end2, intersect))\n            {\n                return intersect;\n            }\n            else\n            {\n                return PointLatLng.Empty;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// p1 and p2 represent two coordinates that make up the bounding box\n        /// pX is a point that we are checking to see if it is inside the box\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;p1&quot;&gt;PointLatLng 1&lt;/param&gt;\n        /// &lt;param name=&quot;p2&quot;&gt;PointLatLng 1&lt;/param&gt;\n        /// &lt;param name=&quot;pX&quot;&gt;PointLatLng to check&lt;/param&gt;\n        /// &lt;returns&gt;True if pX is inside the bounding box, false otherwise&lt;/returns&gt;\n        private static bool IsPointInBoundingBox(PointLatLng p1, PointLatLng p2, PointLatLng pX)\n        {\n            bool betweenLats;\n            bool betweenLons;\n\n            if (p1.Lat &lt; p2.Lat)\n            {\n                betweenLats = (p1.Lat &lt;= pX.Lat &amp;&amp; p2.Lat &gt;= pX.Lat);\n            }\n            else\n            {\n                betweenLats = (p1.Lat &gt;= pX.Lat &amp;&amp; p2.Lat &lt;= pX.Lat);\n            }\n\n            if (p1.Lng &lt; p2.Lng)\n            {\n                betweenLons = (p1.Lng &lt;= pX.Lng &amp;&amp; p2.Lng &gt;= pX.Lng);\n            }\n            else\n            {\n                betweenLons = (p1.Lng &gt;= pX.Lng &amp;&amp; p2.Lng &lt;= pX.Lng);\n            }\n    \n            return (betweenLats &amp;&amp; betweenLons);\n        }\n\n        /// &lt;summary&gt;\n        /// Convert given decimal degrees to radians\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;degrees&quot;&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        internal static double ToRadians(double degrees)\n        {\n            return degrees * (Math.PI / 180d);\n        }\n\n        /// &lt;summary&gt;\n        /// Convert given radians to decimal degrees\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;radians&quot;&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        internal static double ToDegrees(double radians)\n        {\n            return radians * (180d / Math.PI);\n        }</code></pre>\n\n",
    "PostedDate": "2013-08-25T09:24:01.443-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1084679",
    "ThreadId": "454475",
    "Html": "probably, thanks<br />\n",
    "PostedDate": "2013-08-25T10:16:47.273-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1084721",
    "ThreadId": "454475",
    "Html": "Great stuff, Xandolph... Could come in very handy.\r<br />\n<br />\nAnd yes, lines do not follow the curvature of the earth and I dont think Gmaps .NET has an option like geodesic:true, which on google maps, makes all lines follow the curvature of the earth.\r<br />\n<br />\nThis is one thing I really miss because on my application, I really need it when showing a route from say NYC to London, where instead of following the curvature of the Earth, the line is a straight line from point A to point B.\r<br />\n<br />\nIf you come up with a method that returns a line following the curvature of the Earth, please let me know! :-)<br />\n",
    "PostedDate": "2013-08-25T14:41:18.313-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]