[
  {
    "Id": "1137120",
    "ThreadId": "474380",
    "Html": "I'm using GreatMaps to plot journeys of WW1 vessels and ran into the problem that the maps stop at the 180° meridian, i.e. no continuous maps.<br />\n<br />\nI've made changes, which I'll list in the next messages, in order to extend maps to the left and right for some improved displaying around the 180° meridian.<br />\n<br />\nI've only tested it with Google maps, i.e. Mercator projection, and Windows forms, but hope it can help others, too.<br />\nOr better, improve where I failed.<br />\n<br />\nThe new stuff is all enclosed in #if JpContinuousMap.<br />\n<br />\nMy program is called <a href=\"http://journeyplotter.ihostfull.com\" rel=\"nofollow\">Journey Plotter</a>.<br />\nThe changes have not yet been implemented in the latest release.<br />\n",
    "PostedDate": "2013-12-17T06:37:59.87-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137122",
    "ThreadId": "474380",
    "Html": "Changes to <strong>Core.cs</strong>.\r<br />\n<br />\nSome helpers:<br />\n<pre><code>#if JpContinuousMap\n    private GPoint _mapTopLeftPixel;\n    private GPoint _mapBottomRightPixel;\n\n    /// &lt;summary&gt;\n    /// Top-left corner of map in pixels\n    /// &lt;/summary&gt;\n    public GPoint MapTopLeftPixel\n    {\n      get\n      {\n        return _mapTopLeftPixel;\n      }\n    }\n\n    /// &lt;summary&gt;\n    /// Bottom-right corner of map in pixels\n    /// &lt;/summary&gt;\n    public GPoint MapBottomRightPixel\n    {\n      get\n      {\n        return _mapBottomRightPixel;\n      }\n    }\n\n    /// &lt;summary&gt;\n    /// Width of map in pixels\n    /// &lt;/summary&gt;\n    public long MapWidthPixels\n    {\n      get\n      {\n        return _mapBottomRightPixel.X - _mapTopLeftPixel.X + 1;\n      }\n    }\n\n    /// &lt;summary&gt;\n    /// Height of map in pixels\n    /// &lt;/summary&gt;\n    public long MapHeightPixels\n    {\n      get\n      {\n        return _mapBottomRightPixel.Y - _mapTopLeftPixel.Y + 1;\n      }\n    }\n\n    /// &lt;summary&gt;\n    /// Width of maximum number of map tiles in pixels\n    /// &lt;/summary&gt;\n    public long MapTilesWidthPixels\n    {\n      get\n      {\n        return tileRect.Width * (maxOfTiles.Width + 1);\n      }\n    }\n\n    /// &lt;summary&gt;\n    /// Width of extra map zone in pixels\n    /// &lt;/summary&gt;\n    public long MapExtraWidthPixels\n    {\n      get\n      {\n        return tileRect.Width * sizeOfMapArea.Width;\n      }\n    }\n\n    /// &lt;summary&gt;\n    /// Number of extra map zones\n    /// &lt;/summary&gt;\n    public int MapExtraSize\n    {\n      get\n      {\n        return (int) Math.Ceiling((double) MapExtraWidthPixels / MapWidthPixels);\n      }\n    }\n#endif // JpContinuousMap\n</code></pre>\n\nChanges to UpdateBounds:<br />\n<pre><code>    void UpdateBounds()\n    {\n      if (!IsStarted || Provider.Equals(EmptyProvider.Instance))\n      {\n        return;\n      }\n\n      updatingBounds = true;\n\n#if JpContinuousMap\n      // Update map position\n      _mapTopLeftPixel = FromLatLngToLocal(new PointLatLng(Provider.Projection.Bounds.Top, Provider.Projection.Bounds.Left));\n      _mapTopLeftPixel.OffsetNegative(renderOffset);\n      _mapTopLeftPixel.Offset(compensationOffset);\n      _mapBottomRightPixel = FromLatLngToLocal(new PointLatLng(Provider.Projection.Bounds.Bottom, Provider.Projection.Bounds.Right));\n      _mapBottomRightPixel.OffsetNegative(renderOffset);\n      _mapBottomRightPixel.Offset(compensationOffset);\n#endif // JpContinuousMap\n</code></pre>\n\n...<br />\n<pre><code>#if JpContinuousMap\n            // Allow extra tiles to the side of the map\n            if (p.Y &gt;= minOfTiles.Height &amp;&amp; p.Y &lt;= maxOfTiles.Height)\n#else // JpContinuousMap\n            if(p.X &gt;= minOfTiles.Width &amp;&amp; p.Y &gt;= minOfTiles.Height &amp;&amp; p.X &lt;= maxOfTiles.Width &amp;&amp; p.Y &lt;= maxOfTiles.Height)\n#endif // JpContinuousMap\n</code></pre>\n\n...<br />\n<pre><code>#if JpContinuousMap\n              // Add copies of tiles to the side of the map\n              while (dt.PosXY.X &lt; minOfTiles.Width)\n              {\n                dt.PosXY.X += (maxOfTiles.Width + 1);\n              }\n\n              while (dt.PosXY.X &gt; maxOfTiles.Width)\n              {\n                dt.PosXY.X -= (maxOfTiles.Width + 1);\n              }\n#endif // JpContinuousMap\n</code></pre>\n\n",
    "PostedDate": "2013-12-17T06:39:35.81-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137123",
    "ThreadId": "474380",
    "Html": "Changes to <strong>DrawTile.cs</strong><br />\n<pre><code>\n    public bool Equals(DrawTile other)\n    {\n#if JpContinuousMap\n      // Add extra test to allow copies to the side of the map\n      return ((PosXY == other.PosXY) &amp;&amp; (PosPixel == other.PosPixel));\n#else // JpContinuousMap\n      return (PosXY == other.PosXY);\n#endif // JpContinuousMap\n    }\n</code></pre>\n\n",
    "PostedDate": "2013-12-17T06:40:09.647-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137127",
    "ThreadId": "474380",
    "Html": "Changes to <strong>GMapContols.cs</strong><br />\n<pre><code>#if JpContinuousMap\n    // Selection point on control\n    Point selectionStart;\n    Point selectionEnd;\n#else // JpContinuousMap\n    PointLatLng selectionStart;\n    PointLatLng selectionEnd;\n#endif // JpContinuousMap\n\n#if JpContinuousMap\n    public Point ContinuousMapPosition(int x, int y)\n    {\n      int offsetCount;\n\n      // Convert control position to map pixel position\n      GPoint point = new GPoint(x, y);\n      point.OffsetNegative(Core.renderOffset);\n      point.Offset(Core.compensationOffset);\n\n      if (point.X &lt; Core.MapTopLeftPixel.X)\n      {\n        // Left of original map\n        offsetCount = (int) Math.Ceiling((double) (Core.MapTopLeftPixel.X - point.X) / Core.MapWidthPixels);\n\n        if (offsetCount &lt;= Core.MapExtraSize)\n        {\n          point.X += offsetCount * Core.MapWidthPixels;\n        }\n      }\n      else if (point.X &gt; Core.MapBottomRightPixel.X)\n      {\n        // Right of original map\n        offsetCount = (int) Math.Ceiling((double) (point.X - Core.MapBottomRightPixel.X) / Core.MapWidthPixels);\n\n        if (offsetCount &lt;= Core.MapExtraSize)\n        {\n          point.X -= offsetCount * Core.MapWidthPixels;\n        }\n      }\n\n      // Convert map pixel position back to control position\n      point.OffsetNegative(Core.compensationOffset);\n      point.Offset(Core.renderOffset);\n\n      return new Point((int) point.X, (int) point.Y);\n    }\n#endif // JpContinuousMap\n</code></pre>\n\nChanges to SetZoomToFitRect:<br />\n<pre><code>#if JpContinuousMap\n        // If the given rectangle is crossing the map boundery, shift it so it's within the map bounds\n        // and the zoom factor can be determined properly\n        RectLatLng shiftedArea = rect;\n\n        if (shiftedArea.Lng + shiftedArea.WidthLng &gt; Core.Provider.Projection.Bounds.Right)\n        {\n          shiftedArea.Lng = Core.Provider.Projection.Bounds.Right - shiftedArea.WidthLng;\n        }\n        int maxZoom = Core.GetMaxZoomToFitRect(shiftedArea);\n#else // JpContinuousMap\n        int maxZoom = Core.GetMaxZoomToFitRect(rect);\n#endif // JpContinuousMap\n\n        if (maxZoom &gt; 0)\n        {\n#if JpContinuousMap\n          PointLatLng center = new PointLatLng(rect.LocationMiddle.Lat, rect.LocationMiddle.Lng);\n          // Correct center if it is outside the map boundary\n          if (center.Lng &gt; Core.Provider.Projection.Bounds.Right)\n          {\n            center.Lng -= Core.Provider.Projection.Bounds.WidthLng;\n          }\n          else if (center.Lng &lt; Core.Provider.Projection.Bounds.Left)\n          {\n            center.Lng += Core.Provider.Projection.Bounds.WidthLng;\n          }\n#else // JpContinuousMap\n          PointLatLng center = new PointLatLng(rect.Lat - (rect.HeightLat / 2), rect.Lng + (rect.WidthLng / 2));\n#endif // JpContinuousMap\n</code></pre>\n\nChanges to OnPaintOverlays:<br />\n<pre><code>#if JpContinuousMap\n      // Determine if extra map zones are shown, because the overlays have to be drawn in those zones as well\n\n      RectangleF clip = g.VisibleClipBounds;\n      GPoint offset = Core.renderOffset;\n      int startDrawIndex = 0;\n      int endDrawIndex = 0;\n      GPoint topLeft;\n      GPoint bottomRight;\n\n      // Calculate start of left hand side of extra map zone and the total width of map and extra zones on either side\n      topLeft = Core.MapTopLeftPixel;\n      topLeft.Offset(offset);\n      topLeft.OffsetNegative(Core.compensationOffset);\n\n      bottomRight = Core.MapBottomRightPixel;\n      bottomRight.Offset(offset);\n      bottomRight.OffsetNegative(Core.compensationOffset);\n\n      clip.X = topLeft.X - Core.MapExtraWidthPixels - offset.X;\n      clip.Width = Core.MapExtraWidthPixels + Core.MapWidthPixels + Core.MapExtraWidthPixels;\n\n      // Clip the canvas to prevent overlays to be shown outside the extra map zones\n      if (clip != g.VisibleClipBounds)\n      {\n        g.Clip = new System.Drawing.Region(clip);\n      }\n\n      // Determine start index for drawing overlays\n      if (topLeft.X &gt; 0)\n      {\n        startDrawIndex = -1 * (int) Math.Ceiling((double) topLeft.X / (Core.MapExtraWidthPixels / Core.MapExtraSize));\n        if (startDrawIndex &lt; -Core.MapExtraSize)\n        {\n          startDrawIndex = -Core.MapExtraSize;\n        }\n      }\n      else if (bottomRight.X &lt; 0)\n      {\n        startDrawIndex = (int) Math.Ceiling((double) -bottomRight.X / (Core.MapExtraWidthPixels / Core.MapExtraSize));\n      }\n\n      // Determine end index for drawing overlays\n      if (bottomRight.X &lt; Core.Width)\n      {\n        endDrawIndex = (int) Math.Ceiling((double) (Core.Width - bottomRight.X) / (Core.MapExtraWidthPixels / Core.MapExtraSize));\n        if (endDrawIndex &gt; Core.MapExtraSize)\n        {\n          endDrawIndex = Core.MapExtraSize;\n        }\n      }\n      else if (topLeft.X &gt; Core.Width)\n      {\n        endDrawIndex = (int) Math.Ceiling((double) (Core.Width - topLeft.X) / (Core.MapExtraWidthPixels / Core.MapExtraSize)) - 1;\n      }\n\n      // Shift the canvas to the left\n      g.TranslateTransform((startDrawIndex - 1) * Core.MapTilesWidthPixels, 0);\n\n      for (int drawIndex = startDrawIndex; drawIndex &lt;= endDrawIndex; drawIndex++)\n      {\n        // Shift the canvas one map width to the right\n        g.TranslateTransform(Core.MapTilesWidthPixels, 0);\n#endif // JpContinuousMap\n\n#if !PocketPC\n        g.SmoothingMode = SmoothingMode.HighQuality;\n#endif\n        foreach (GMapOverlay o in Overlays)\n        {\n          if (o.IsVisibile)\n          {\n            o.OnRender(g);\n          }\n        }\n#if JpContinuousMap\n      }\n\n      // Remove cliping\n      g.ResetClip();\n\n      // Shift the canvas back to set the map centre in the correct position again\n      g.TranslateTransform(-endDrawIndex * Core.MapTilesWidthPixels, 0);\n#endif // JpContinuousMap\n</code></pre>\n\n...<br />\n<pre><code>      if (!SelectedArea.IsEmpty)\n      {\n#if JpContinuousMap\n        // Make sure the start is left of end and top is above bottom\n        Point pointStart = selectionStart;\n        Point pointEnd = selectionEnd;\n\n        if (pointEnd.X &lt; pointStart.X)\n        {\n          int temp = pointStart.X;\n          pointStart.X = pointEnd.X;\n          pointEnd.X = temp;\n        }\n        if (pointEnd.Y &lt; pointStart.Y)\n        {\n          int temp = pointStart.Y;\n          pointStart.Y = pointEnd.Y;\n          pointEnd.Y = temp;\n        }\n\n        Rectangle selection = new Rectangle(pointStart.X, pointStart.Y, pointEnd.X - pointStart.X, pointEnd.Y - pointStart.Y);\n\n        g.DrawRectangle(SelectionPen, selection);\n        g.FillRectangle(SelectedAreaFill, selection);\n#else // JpContinuousMap\n        GPoint p1 = FromLatLngToLocal(SelectedArea.LocationTopLeft);\n        GPoint p2 = FromLatLngToLocal(SelectedArea.LocationRightBottom);\n\n        long x1 = p1.X;\n        long y1 = p1.Y;\n        long x2 = p2.X;\n        long y2 = p2.Y;\n\n        g.DrawRectangle(SelectionPen, x1, y1, x2 - x1, y2 - y1);\n        g.FillRectangle(SelectedAreaFill, x1, y1, x2 - x1, y2 - y1);\n#endif // JpContinuousMap\n      }\n</code></pre>\n\n",
    "PostedDate": "2013-12-17T06:42:53.383-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137129",
    "ThreadId": "474380",
    "Html": "Changes to <strong>GMapControl.cs</strong> continued.\r<br />\n<br />\nChanges to OnMouseDown:<br />\n<pre><code>        else if (!isSelected)\n        {\n          isSelected = true;\n          SelectedArea = RectLatLng.Empty;\n#if JpContinuousMap\n          selectionEnd = Point.Empty;\n          selectionStart = e.Location;\n#else // JpContinuousMap\n          selectionEnd = PointLatLng.Empty;\n          selectionStart = FromLocalToLatLng(e.X, e.Y);\n#endif // JpContinuousMap\n        }\n</code></pre>\n\nChanges to OnMouseUp:<br />\n<pre><code>          if (OnSelectionChange != null)\n          {\n            OnSelectionChange(SelectedArea, zoomtofit);\n          }\n#if JpContinuousMap\n          // Clear selection\n          selectionStart = Point.Empty;\n          selectionEnd = Point.Empty;\n          SelectedArea = RectLatLng.Empty;\n#endif // JpContinuousMap\n</code></pre>\n\nChanges to OnMouseClick:<br />\n<pre><code>      if (!Core.IsDragging)\n      {\n#if JpContinuousMap\n        // Translate mouse position as if it is over the original map section\n        Point mouse = ContinuousMapPosition(e.X, e.Y);\n        e = new MouseEventArgs(e.Button, e.Clicks, mouse.X, mouse.Y, e.Delta);\n#endif // JpContinuousMap\n</code></pre>\n\nChanges to OnMouseMove:<br />\n<pre><code>        if (isSelected &amp;&amp; !selectionStart.IsEmpty &amp;&amp; (Form.ModifierKeys == Keys.Alt || Form.ModifierKeys == Keys.Shift || DisableAltForSelection))\n        {\n#if JpContinuousMap\n          selectionEnd = e.Location;\n\n          // Limit selection to map control width\n          if (selectionEnd.X &gt; Width)\n          {\n            selectionEnd.X = Width;\n          }\n          if (selectionEnd.X &lt; 0)\n          {\n            selectionEnd.X = 0;\n          }\n\n          // Limit the selection to the map width\n          if (selectionEnd.X - selectionStart.X &gt;= Core.MapWidthPixels)\n          {\n            selectionEnd.X = selectionStart.X + (int) Core.MapWidthPixels - 1;\n          }\n          else if (selectionStart.X - selectionEnd.X &gt;= Core.MapWidthPixels)\n          {\n            selectionEnd.X = selectionStart.X - (int) Core.MapWidthPixels + 1;\n          }\n\n          // Make sure the start is left of end and top is above bottom\n          Point pointStart = selectionStart;\n          Point pointEnd = selectionEnd;\n\n          if (pointEnd.X &lt; pointStart.X)\n          {\n            int temp = pointStart.X;\n            pointStart.X = pointEnd.X;\n            pointEnd.X = temp;\n          }\n          if (pointEnd.Y &lt; pointStart.Y)\n          {\n            int temp = pointStart.Y;\n            pointStart.Y = pointEnd.Y;\n            pointEnd.Y = temp;\n          }\n\n          // Convert latitude/longitude pairs\n          PointLatLng positionStart = FromLocalToLatLng(pointStart.X, pointStart.Y);\n          PointLatLng positionEnd = FromLocalToLatLng(pointEnd.X, pointEnd.Y);\n\n          double width = positionEnd.Lng - positionStart.Lng;\n          double height = positionStart.Lat - positionEnd.Lat;\n\n          if (positionStart.Lng &gt; positionEnd.Lng)\n          {\n            // The selection must have crossed the map boundary\n            width += Core.Provider.Projection.Bounds.WidthLng;\n          }\n          SelectedArea = new RectLatLng(positionStart.Lat, positionStart.Lng, width, height);\n#else // JpContinuousMap\n          selectionEnd = FromLocalToLatLng(e.X, e.Y);\n          {\n            GMap.NET.PointLatLng p1 = selectionStart;\n            GMap.NET.PointLatLng p2 = selectionEnd;\n\n            double x1 = Math.Min(p1.Lng, p2.Lng);\n            double y1 = Math.Max(p1.Lat, p2.Lat);\n            double x2 = Math.Max(p1.Lng, p2.Lng);\n            double y2 = Math.Min(p1.Lat, p2.Lat);\n\n            SelectedArea = new RectLatLng(y1, x1, x2 - x1, y1 - y2);\n          }\n#endif // JpContinuousMap\n        }\n        else\n#endif\n          if (Core.mouseDown.IsEmpty)\n          {\n#if JpContinuousMap\n            // Translate mouse position as if it is over the original map section\n            Point mouse = ContinuousMapPosition(e.X, e.Y);\n            e = new MouseEventArgs(e.Button, e.Clicks, mouse.X, mouse.Y, e.Delta);\n#endif // JpContinuousMap\n</code></pre>\n\nChanges to FromLocalToLatLng:<br />\n<pre><code>    public PointLatLng FromLocalToLatLng(int x, int y)\n    {\n#if JpContinuousMap\n      // Translate position as if it is over the original map section\n      Point point = ContinuousMapPosition(x, y);\n      x = point.X;\n      y = point.Y;\n#endif // JpContinuousMap\n</code></pre>\n\nChanges to MapProvider:<br />\n<pre><code>          RectLatLng viewarea = SelectedArea;\n#if JpContinuousMap\n          if (viewarea != RectLatLng.Empty)\n          {\n            PointLatLng center = new PointLatLng(viewarea.LocationMiddle.Lat, viewarea.LocationMiddle.Lng);\n            // Correct center if it is outside the map boundary\n            if (center.Lng &gt; Core.Provider.Projection.Bounds.Right)\n            {\n              center.Lng -= Core.Provider.Projection.Bounds.WidthLng;\n            }\n            else if (center.Lng &lt; Core.Provider.Projection.Bounds.Left)\n            {\n              center.Lng += Core.Provider.Projection.Bounds.WidthLng;\n            }\n            Position = center;\n          }\n#else // JpContinuousMap\n          if (viewarea != RectLatLng.Empty)\n          {\n            Position = new PointLatLng(viewarea.Lat - viewarea.HeightLat / 2, viewarea.Lng + viewarea.WidthLng / 2);\n          }\n#endif // JpContinuousMap\n</code></pre>\n\n",
    "PostedDate": "2013-12-17T06:44:43.473-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1137204",
    "ThreadId": "474380",
    "Html": "thanks for your effort, i'll check it out<br />\n",
    "PostedDate": "2013-12-17T09:50:51.123-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]