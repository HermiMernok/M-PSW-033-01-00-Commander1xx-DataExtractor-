[
  {
    "Id": "1431219",
    "ThreadId": "640246",
    "Html": "I want to create a smooth animated drag effect just like Google Maps  (if you know what I am talking about).<br />\n<br />\nI warped <code>GMapControl</code> class and successfully implemented  smooth zoom by overriding the <code>OnMouseWheel</code> method and applying a <code>DoubleAnimation</code> using exponential easing on the <code>Zoom</code> property every time the wheel is turned.<br />\n<br />\nIn order to implement smooth drag like Google I created <code>MapOffset</code> property, which on every value change will call <code>Offset</code> function from the <code>MapControl</code> class with the new offset point. Creating the <code>MapOffset</code> granted me the ability to animate map movement.<br />\n<br />\n__The problem is that <code>Offset</code> function only accept integer values which is not accurate enough for making smooth animations.__<br />\n<br />\nIs there another way to create a smooth drag?<br />\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">class</span> SmoothMap : GMapControl\n{\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">readonly</span> DependencyProperty MapOffsetProperty = DependencyProperty.Register(<span style=\"color:#A31515;\">&quot;MapOffset&quot;</span>, \n                     <span style=\"color:Blue;\">typeof</span>(Point), <span style=\"color:Blue;\">typeof</span>(SmoothMap), <span style=\"color:Blue;\">new</span> FrameworkPropertyMetadata(<span style=\"color:Blue;\">new</span>  \n                     PropertyChangedCallback(OnM_OffsetPropertyChanged)));\n\n        <span style=\"color:Blue;\">private</span> Storyboard movementSb;\n        <span style=\"color:Blue;\">private</span> PointAnimation movementAnimation;\n\n        <span style=\"color:Blue;\">public</span> SmoothMap()\n        {\n            movementSb = <span style=\"color:Blue;\">new</span> Storyboard();\n            movementAnimation = <span style=\"color:Blue;\">new</span> PointAnimation();\n            movementAnimation.From = <span style=\"color:Blue;\">new</span> Point(0, 0);\n            movementAnimation.Duration = <span style=\"color:Blue;\">new</span> Duration(TimeSpan.FromSeconds(1));\n            movementAnimation.FillBehavior = FillBehavior.HoldEnd;\n            ExponentialEase ease = <span style=\"color:Blue;\">new</span> ExponentialEase();\n            ease.EasingMode = EasingMode.EaseOut; \n            ease.Exponent = 6;\n            movementAnimation.EasingFunction = ease;\n\n            movementSb.Children.Add(movementAnimation);\n\n            Storyboard.SetTarget(movementAnimation, <span style=\"color:Blue;\">this</span>);\n            Storyboard.SetTargetProperty(movementAnimation, <span style=\"color:Blue;\">new</span> PropertyPath(MapOffsetProperty));\n         }\n\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">void</span> OnMapOffsetPropertyChanged(DependencyObject source,                                                                                                      DependencyPropertyChangedEventArgs e)\n        {\n            SmoothMap sm = source <span style=\"color:Blue;\">as</span> SmoothMap;\n            Point p = (Point)e.NewValue;\n\n            sm.Offset((<span style=\"color:Blue;\">int</span>)p.X, (<span style=\"color:Blue;\">int</span>)p.Y);\n        }\n\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">const</span> <span style=\"color:Blue;\">int</span> OffsetConstant = 3;\n        <span style=\"color:Blue;\">bool</span> isDragging = <span style=\"color:Blue;\">false</span>;\n        Queue&lt;Tuple&lt;Point, <span style=\"color:Blue;\">int</span>&gt;&gt; lastPos = <span style=\"color:Blue;\">new</span> Queue&lt;Tuple&lt;Point, <span style=\"color:Blue;\">int</span>&gt;&gt;();\n        <span style=\"color:Blue;\">protected</span> <span style=\"color:Blue;\">override</span> <span style=\"color:Blue;\">void</span> OnMouseMove(System.Windows.Input.MouseEventArgs e)\n        {\n            <span style=\"color:Blue;\">base</span>.OnMouseMove(e);\n\n            <span style=\"color:Blue;\">if</span>(e.LeftButton == System.Windows.Input.MouseButtonState.Pressed)\n            {\n                isDragging = <span style=\"color:Blue;\">true</span>;\n                lastPos.Enqueue(<span style=\"color:Blue;\">new</span> Tuple&lt;Point, <span style=\"color:Blue;\">int</span>&gt;(e.GetPosition(<span style=\"color:Blue;\">this</span>), e.Timestamp));\n                <span style=\"color:Blue;\">if</span> (lastPos.Count == 10)\n                {\n                    lastPos.Dequeue();\n                }\n            }\n            <span style=\"color:Blue;\">else</span> <span style=\"color:Blue;\">if</span>(e.LeftButton == System.Windows.Input.MouseButtonState.Released &amp;&amp; isDragging)\n            {\n                Tuple&lt;Point, <span style=\"color:Blue;\">int</span>&gt; first = lastPos.First();\n                Tuple&lt;Point, <span style=\"color:Blue;\">int</span>&gt; last = lastPos.Last();\n\n                <span style=\"color:Blue;\">if</span> (e.Timestamp - last.Item2 &lt; 200)\n                {\n                    <span style=\"color:Blue;\">long</span> deltaT = last.Item2 - first.Item2;\n                    <span style=\"color:Blue;\">double</span> deltaX = (last.Item1.X - first.Item1.X);\n                    <span style=\"color:Blue;\">double</span> deltaY = (last.Item1.Y - first.Item1.Y);\n\n                    <span style=\"color:Blue;\">double</span> velocity_X = deltaX / (<span style=\"color:Blue;\">double</span>)deltaT;\n                    <span style=\"color:Blue;\">double</span> velocity_Y = deltaY / (<span style=\"color:Blue;\">double</span>)deltaT;\n\n                    movementSb.Stop();\n\n                    Debug.WriteLine(<span style=\"color:#A31515;\">&quot;To: &quot;</span> + velocity_X);\n\n                    movementAnimation.To = <span style=\"color:Blue;\">new</span> Point(velocity_X * OffsetConstant , velocity_Y * OffsetConstant );\n\n                    lastPos.Clear();\n                    isDragging = <span style=\"color:Blue;\">false</span>;\n\n                    movementSb.Begin();\n                }   \n            }\n        }\n}\r\n</pre></div>What basically I am doing in order to have a smooth drag when the user releases the mouse, is saving the last mouse movement by saving the last 10 move messages. After that I calculate the speed of the movement and using the speed in the animation.<br />\n",
    "PostedDate": "2015-06-20T13:38:39.58-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]